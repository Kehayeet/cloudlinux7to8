# Copyright 1999 - 2023. Plesk International GmbH. All rights reserved.
from .action import ActiveAction

import os
import pwd
import shutil
import typing

from common import util, log, leapp_configs, files


# We should do rebundling of ruby applications after the conversion
# because some of our libraries will be missing.
# The prime example of missing library - libmysqlclient.so.18 required by mysql2 gem
class RebundleRubyApplications(ActiveAction):
    PLESK_APACHE_CONFIGS_PATH = "/etc/httpd/conf/plesk.conf.d/vhosts/"

    def __init__(self):
        self.name = "rebundling ruby applications"
        self.description = "rebundling ruby applications"

    def _is_ruby_domain(self, domain_path) -> bool:
        return os.path.exists(os.path.join(domain_path, ".rbenv"))

    def _is_required(self) -> bool:
        if not os.path.exists("/var/lib/rbenv/versions/"):
            return False

        return any(self._is_ruby_domain(domain) for domain in os.scandir("/var/www/vhosts"))

    def _prepare_action(self) -> None:
        pass

    def _get_ruby_application_path_by_config(self, domain_name: str) -> str:
        apache_config = os.path.join(self.PLESK_APACHE_CONFIGS_PATH, domain_name + ".conf")

        if not os.path.isfile(apache_config) or not files.find_file_substrings(apache_config, "PassengerRuby"):
            # Likely it means ruby application is not enabled, so we need to do direct search in the filesystem
            return None

        application_root = files.find_file_substrings(apache_config, "PassengerAppRoot")
        if not application_root:
            return None

        # Record format is: PassengerAppRoot "[path]"
        # We can expect it is always in this format since configuration is generated by plesk
        return application_root[0].split()[1].strip("\"")

    def _get_ruby_application_path_by_bundle_subdir(self, domain_home: str) -> str:
        bundle = files.find_subdirectory_by(domain_home,
                                            lambda subdir: os.path.basename(subdir) == "bundle" and
                                                           os.path.exists(os.path.join(subdir, "ruby")))
        if bundle is None or not os.path.isdir(bundle):
            return None

        return os.path.dirname(os.path.dirname(bundle))

    def _get_ruby_application_paths(self, domain_path: str) -> typing.Tuple[str, str]:
        app_directory = self._get_ruby_application_path_by_config(domain_path.name)
        if app_directory is None:
            log.debug("Ruby application is disabled. Search for application root in filesystem. Domain home directory: {}".format(domain_path))
            app_directory = self._get_ruby_application_path_by_bundle_subdir(domain_path)

        if app_directory is None:
            return None, None

        return app_directory, os.path.join(app_directory, "vendor", "bundle")

    def _post_action(self) -> None:
        ruby_domains = (domain_path for domain_path in os.scandir("/var/www/vhosts") if self._is_ruby_domain(domain_path))
        for domain_path in ruby_domains:
            log.debug("Re-bundling ruby application in domain: {}".format(domain_path.name))

            app_directory, bundle = self._get_ruby_application_paths(domain_path)

            if bundle is None or not os.path.isdir(bundle):
                log.debug("Skip re-bundling for non bundling domain '{}'".format(domain_path.name))
                continue

            stat_info = os.stat(app_directory)
            username = pwd.getpwuid(stat_info.st_uid).pw_name

            log.debug("Bundle: {}. App directory: {}. Username: {}".format(bundle, app_directory, username))

            shutil.rmtree(bundle)
            util.logged_check_call(["/usr/sbin/plesk", "sbin", "rubymng", "run-bundler", username, app_directory])

    def _revert_action(self) -> None:
        pass

    def estimate_post_time(self) -> int:
        return 60 * len([domain_path for domain_path in os.scandir("/var/www/vhosts") if self._is_ruby_domain(domain_path)])


class FixupImunify(ActiveAction):
    def __init__(self):
        self.name = "fixing up imunify360"

    def _is_required(self) -> bool:
        return len(files.find_files_case_insensitive("/etc/yum.repos.d", ["imunify360.repo"])) > 0

    def _prepare_action(self) -> None:
        repofiles = files.find_files_case_insensitive("/etc/yum.repos.d", ["imunify*.repo"])

        leapp_configs.add_repositories_mapping(repofiles)

        # For some reason leapp replace the libssh2 packageon installation. It's fine in most cases,
        # but imunify packages require libssh2. So we should use PRESENT action to keep it.
        leapp_configs.set_package_action("libssh2", leapp_configs.LeappActionType.PRESENT)

    def _post_action(self) -> None:
        pass

    def _revert_action(self) -> None:
        pass


class AdoptKolabRepositories(ActiveAction):
    def __init__(self):
        self.name = "adopting kolab repositories"

    def _is_required(self) -> bool:
        return len(files.find_files_case_insensitive("/etc/yum.repos.d", ["kolab*.repo"])) > 0

    def _prepare_action(self) -> None:
        repofiles = files.find_files_case_insensitive("/etc/yum.repos.d", ["kolab*.repo"])

        leapp_configs.add_repositories_mapping(repofiles, ignore=["kolab-16-source",
                                                                  "kolab-16-testing-source",
                                                                  "kolab-16-testing-candidate-source"])

    def _post_action(self) -> None:
        for file in files.find_files_case_insensitive("/etc/yum.repos.d", ["kolab*.repo"]):
            leapp_configs.adopt_repositories(file)

        util.logged_check_call(["/usr/bin/dnf", "-y", "update"])

    def _revert_action(self) -> None:
        pass

    def estimate_prepare_time(self) -> int:
        return 30

    def estimate_post_time(self) -> int:
        return 2 * 60
